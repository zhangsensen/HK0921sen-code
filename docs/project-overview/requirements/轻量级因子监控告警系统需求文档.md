# 轻量级因子监控告警系统需求文档

## 1. 项目概述

### 1.1 项目背景
基于现有的港股因子挖掘系统，开发一个轻量级的监控告警系统，用于实时监控因子表现、系统运行状态和异常情况。该系统面向个人开发者，采用简单高效的技术栈，提供核心监控功能。

### 1.2 目标用户
- 个人量化开发者
- 因子研究分析师
- 系统运维人员

### 1.3 核心价值
- 实时掌握因子表现
- 及时发现系统异常
- 提供决策支持数据
- 降低人工监控成本

## 2. 系统架构

### 2.1 技术栈选择
```yaml
后端框架: Flask (轻量级,易于部署)
数据库: SQLite (无需额外服务,文件存储)
前端: Bootstrap (响应式,移动友好)
监控: 自定义Python脚本
告警: 邮件+Webhook
部署: Docker+Gunicorn (可选)
```

### 2.2 架构设计
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   数据采集层    │    │   数据处理层    │    │   展示告警层    │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ • 因子数据采集  │    │ • 数据聚合计算  │    │ • Web仪表盘     │
│ • 系统指标采集  │───▶│ • 异常检测算法  │───▶│ • 告警通知     │
│ • 外部数据接口  │    │ • 缓存管理      │    │ • 报表生成     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 2.3 模块划分
- **数据采集模块**: 定时收集因子数据和系统指标
- **数据处理模块**: 清洗、聚合、计算关键指标
- **监控分析模块**: 异常检测、趋势分析、阈值判断
- **告警通知模块**: 多渠道告警、告警级别管理
- **Web展示模块**: 仪表盘、历史查询、配置管理

## 3. 功能需求

### 3.1 核心监控功能

#### 3.1.1 因子表现监控
```python
# 因子表现指标
metrics = {
    "sharpe_ratio": "实时夏普比率",
    "max_drawdown": "最大回撤",
    "win_rate": "胜率统计",
    "profit_factor": "盈亏比",
    "stability_score": "稳定性评分",
    "ic_value": "信息系数",
    "turnover_rate": "换手率"
}
```

#### 3.1.2 系统状态监控
- 数据更新延迟监控
- 计算任务执行状态
- 内存使用情况
- CPU使用率
- 磁盘空间使用

#### 3.1.3 异常检测功能
- 数据质量异常检测
- 因子表现异常波动
- 系统性能异常
- 交易成本异常

### 3.2 告警功能

#### 3.2.1 告警级别
- **紧急**: 系统宕机、数据丢失
- **重要**: 因子失效、性能异常
- **警告**: 指标波动、资源紧张
- **信息**: 正常状态更新

#### 3.2.2 告警渠道
- 邮件通知
- Webhook推送
- 短信接口（可选）
- 企业微信（可选）

#### 3.2.3 告警规则
```yaml
告警规则:
  - 条件: "夏普比率 < 0.5"
    级别: "重要"
    动作: "邮件通知"

  - 条件: "最大回撤 > 20%"
    级别: "紧急"
    动作: "立即通知"

  - 条件: "数据延迟 > 30分钟"
    级别: "警告"
    动作: "记录日志"
```

### 3.3 Web界面功能

#### 3.3.1 仪表盘
- 实时数据展示
- 关键指标卡片
- 趋势图表
- 告警状态

#### 3.3.2 历史查询
- 因子表现历史
- 告警记录查询
- 系统日志查看
- 数据导出功能

#### 3.3.3 配置管理
- 监控项配置
- 告警规则设置
- 通知渠道管理
- 用户权限控制

## 4. 技术实现方案

### 4.1 数据库设计

#### 4.1.1 监控指标表
```sql
CREATE TABLE monitoring_metrics (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    metric_name VARCHAR(50) NOT NULL,
    metric_value FLOAT NOT NULL,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    factor_name VARCHAR(100),
    timeframe VARCHAR(10)
);
```

#### 4.1.2 告警记录表
```sql
CREATE TABLE alert_records (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    alert_type VARCHAR(20) NOT NULL,
    alert_level VARCHAR(10) NOT NULL,
    alert_message TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    resolved_at DATETIME,
    status VARCHAR(10) DEFAULT 'active'
);
```

#### 4.1.3 系统状态表
```sql
CREATE TABLE system_status (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    component_name VARCHAR(50) NOT NULL,
    status VARCHAR(20) NOT NULL,
    cpu_usage FLOAT,
    memory_usage FLOAT,
    disk_usage FLOAT,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

### 4.2 数据采集模块

#### 4.2.1 因子数据采集
```python
class FactorDataCollector:
    def __init__(self, db_manager):
        self.db_manager = db_manager

    def collect_factor_metrics(self, factor_name, timeframe):
        """采集因子表现指标"""
        # 从现有系统获取因子数据
        # 计算关键指标
        # 存储到监控数据库

    def collect_system_metrics(self):
        """采集系统运行指标"""
        # CPU、内存、磁盘使用率
        # 数据更新延迟
        # 任务执行状态
```

#### 4.2.2 定时任务调度
```python
from apscheduler.schedulers.background import BackgroundScheduler

class MonitoringScheduler:
    def __init__(self):
        self.scheduler = BackgroundScheduler()

    def setup_jobs(self):
        # 每5分钟采集一次因子数据
        self.scheduler.add_job(
            collect_factor_metrics,
            'interval',
            minutes=5
        )

        # 每1分钟采集一次系统指标
        self.scheduler.add_job(
            collect_system_metrics,
            'interval',
            minutes=1
        )
```

### 4.3 告警引擎

#### 4.3.1 告警规则引擎
```python
class AlertEngine:
    def __init__(self, notification_manager):
        self.rules = []
        self.notification_manager = notification_manager

    def add_rule(self, condition, level, action):
        """添加告警规则"""
        self.rules.append({
            'condition': condition,
            'level': level,
            'action': action
        })

    def check_alerts(self, metrics):
        """检查告警条件"""
        for rule in self.rules:
            if self.evaluate_condition(rule['condition'], metrics):
                self.trigger_alert(rule, metrics)

    def trigger_alert(self, rule, metrics):
        """触发告警"""
        alert = {
            'type': 'metric_anomaly',
            'level': rule['level'],
            'message': f"指标异常: {rule['condition']}",
            'metrics': metrics
        }
        self.notification_manager.send_alert(alert)
```

### 4.4 Web API接口

#### 4.4.1 Flask应用结构
```python
from flask import Flask, jsonify, request
from flask_cors import CORS

app = Flask(__name__)
CORS(app)

@app.route('/api/metrics')
def get_metrics():
    """获取监控指标"""
    timeframe = request.args.get('timeframe', '1h')
    metrics = db_manager.get_latest_metrics(timeframe)
    return jsonify(metrics)

@app.route('/api/alerts')
def get_alerts():
    """获取告警记录"""
    alerts = db_manager.get_alert_records()
    return jsonify(alerts)

@app.route('/api/system/status')
def get_system_status():
    """获取系统状态"""
    status = db_manager.get_system_status()
    return jsonify(status)
```

## 5. 部署配置

### 5.1 配置文件设计

#### 5.1.1 主配置文件 (config.yaml)
```yaml
app:
  name: "Factor Monitor"
  version: "1.0.0"
  debug: false

database:
  path: "./monitoring.db"

monitoring:
  interval_seconds: 300
  max_records: 10000

alerting:
  enabled: true
  email:
    enabled: true
    smtp_server: "smtp.gmail.com"
    smtp_port: 587
    username: "your_email@gmail.com"
    password: "your_password"

webhook:
  enabled: true
  url: "https://your-webhook-url.com/alert"

logging:
  level: "INFO"
  file: "./monitoring.log"
  max_size: "10MB"
  backup_count: 5
```

#### 5.1.2 告警规则配置 (alert_rules.yaml)
```yaml
rules:
  - name: "sharpe_ratio_low"
    condition: "sharpe_ratio < 0.5"
    level: "important"
    message: "夏普比率过低"

  - name: "max_drawdown_high"
    condition: "max_drawdown > 0.2"
    level: "critical"
    message: "最大回撤过高"

  - name: "data_delay"
    condition: "data_delay_minutes > 30"
    level: "warning"
    message: "数据更新延迟"
```

### 5.2 Docker部署
```dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

EXPOSE 5000

CMD ["gunicorn", "--bind", "0.0.0.0:5000", "--workers", "4", "app:app"]
```

## 6. 开发计划

### 6.1 开发阶段划分

#### 第一阶段 (1-2天): 基础框架搭建
- 项目结构设计
- 数据库表创建
- Flask应用初始化
- 基础配置管理

#### 第二阶段 (2-3天): 核心功能实现
- 数据采集模块
- 告警引擎开发
- 基础Web API
- 告警规则配置

#### 第三阶段 (2-3天): 界面和优化
- Web仪表盘开发
- 告警通知功能
- 性能优化
- 测试和调试

### 6.2 技术难点和解决方案

#### 6.2.1 数据采集性能
- **问题**: 频繁数据采集可能影响主系统性能
- **解决**: 使用独立进程、缓存机制、异步处理

#### 6.2.2 告警准确性
- **问题**: 避免误报和漏报
- **解决**: 动态阈值、历史数据分析、多条件判断

#### 6.2.3 系统资源占用
- **问题**: 监控系统本身资源消耗
- **解决**: 轻量级设计、资源限制、定期清理

## 7. 扩展性设计

### 7.1 插件化架构
- 监控项插件
- 告警渠道插件
- 数据源插件

### 7.2 API接口设计
- RESTful API设计
- WebSocket实时数据
- 第三方系统集成接口

### 7.3 多租户支持
- 用户权限管理
- 数据隔离
- 个性化配置

## 8. 测试策略

### 8.1 单元测试
- 数据采集功能测试
- 告警规则测试
- 数据库操作测试

### 8.2 集成测试
- 端到端流程测试
- 告警通知测试
- Web界面测试

### 8.3 性能测试
- 并发数据处理测试
- 长时间运行稳定性测试
- 内存泄漏测试

## 9. 文档计划

### 9.1 技术文档
- API文档
- 部署文档
- 配置说明

### 9.2 用户文档
- 使用指南
- 常见问题
- 故障排除

## 10. 总结

本轻量级因子监控告警系统设计遵循简单高效的原则，采用成熟的技术栈，提供了完整的因子监控和告警功能。系统具有良好的扩展性和维护性，适合个人开发者和团队使用。

通过该系统，用户可以实时掌握因子表现和系统状态，及时发现和处理异常情况，提高量化交易的稳定性和效率。

系统预计开发周期为3-4天，总代码量控制在2000-3000行，确保快速交付和易于维护。